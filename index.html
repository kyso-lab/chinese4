<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°ˆæ¥­ç²¾æº–çœ¼å‹•è¨“ç·´ç³»çµ±</title>
    
    <script src="https://webgazer.cs.brown.edu/webgazer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>

    <style>
        :root {
            --primary: #00FF7F;
            --accent: #FFD700;
            --bg: #000;
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: var(--bg); color: white;
            font-family: 'PingFang HK', 'Helvetica Neue', sans-serif;
            overflow: hidden; touch-action: none;
        }

        /* --- è¦–è¦ºå®šä½ç›£æ§ --- */
        #calibration-guide {
            position: fixed; top: 15px; left: 15px;
            width: 160px; height: 120px;
            background: #111; border: 2px solid #333;
            border-radius: 12px; overflow: hidden; z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        #status-text {
            position: absolute; bottom: 0; width: 100%;
            background: rgba(0,0,0,0.7); font-size: 11px;
            text-align: center; color: var(--primary); padding: 2px 0;
        }

        /* --- æ³¨è¦–é» (Gaze Dot) --- */
        #gaze-dot {
            position: fixed; width: 26px; height: 26px;
            border: 2px solid white; border-radius: 50%;
            background: rgba(255, 0, 0, 0.5);
            pointer-events: none; z-index: 2000;
            transform: translate(-50%, -50%);
            display: none;
        }

        /* --- è¨­ç½®é  --- */
        .overlay-screen {
            position: absolute; inset: 0; background: var(--bg);
            z-index: 5000; display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center;
        }

        /* æ ¡æ­£é»æ¨£å¼ (å¢åŠ é€²åº¦ç’°æ”¯æŒ) */
        .calib-point-wrapper {
            position: absolute; width: 100px; height: 100px;
            display: flex; align-items: center; justify-content: center;
            transform: translate(-50%, -50%);
            z-index: 6000;
        }

        .calib-point {
            width: 70px; height: 70px;
            background: var(--accent); border-radius: 50%;
            border: 4px solid white;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.8rem; font-weight: bold; color: black;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
        }

        .calib-ring {
            position: absolute; width: 100%; height: 100%;
            transform: rotate(-90deg);
        }
        .calib-ring circle {
            fill: none; stroke: var(--primary);
            stroke-width: 6; stroke-dasharray: 283; stroke-dashoffset: 283;
            stroke-linecap: round;
        }

        /* éŠæˆ²ç‰©ä»¶ */
        .target-wrapper {
            position: absolute; display: flex; justify-content: center; align-items: center;
            z-index: 10; transform: translate(-50%, -50%);
        }
        .target-icon { font-size: 8rem; user-select: none; }

        .progress-ring {
            position: absolute; width: 140%; height: 140%;
            transform: rotate(-90deg);
        }
        .progress-ring circle {
            fill: none; stroke: var(--primary);
            stroke-width: 8; stroke-dasharray: 283; stroke-dashoffset: 283;
            stroke-linecap: round;
        }

        .btn-start {
            background: var(--primary); color: #000; padding: 20px 60px;
            font-size: 2rem; border-radius: 50px; border: none;
            font-weight: bold; cursor: pointer; margin-top: 20px;
        }
        .btn-start:disabled { background: #333; color: #777; }

        #webgazerGazeDot { display: none !important; }
    </style>
</head>
<body>

    <div id="calibration-guide">
        <div id="status-text">æ­£åœ¨å•Ÿå‹•é¡é ­...</div>
    </div>

    <div id="gaze-dot"></div>

    <!-- å•Ÿå‹•ç•«é¢ -->
    <div id="setup-screen" class="overlay-screen">
        <h1 style="color: var(--accent); font-size: 3rem;">è¦–è¦ºè¿½è¹¤è¨“ç·´</h1>
        <p style="font-size: 1.2rem; color: #aaa; max-width: 80%;">è«‹çœ‹è‘—é¡é ­ï¼Œæº–å‚™å¥½å¾ŒæŒ‰ä¸‹æ–¹æŒ‰éˆ•</p>
        <button id="btn-init" class="btn-start" onclick="startCalibrationFlow()" disabled>è¼‰å…¥ç³»çµ±ä¸­...</button>
    </div>

    <!-- æ ¡æ­£ç•«é¢ (ç¾åœ¨æ”¯æ´çœ¼ç›æ³¨è¦–é»é¸) -->
    <div id="calibration-screen" class="overlay-screen" style="display: none; background: #111;">
        <h2 id="calib-instruction" style="position:absolute; top:40px; color:white; width: 80%;">è«‹çœ¼ç›ç›¯è‘—é»ƒè‰²åœ“åœˆç›´åˆ°å®ƒæ¶ˆå¤±</h2>
        
        <div id="calib-container">
            <!-- æ ¡æ­£é» 1-5 -->
            <div id="cp1" class="calib-point-wrapper" style="top:20%; left:20%;">
                <svg class="calib-ring" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45"></circle></svg>
                <div class="calib-point">1</div>
            </div>
            <div id="cp2" class="calib-point-wrapper" style="top:20%; left:80%;">
                <svg class="calib-ring" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45"></circle></svg>
                <div class="calib-point">2</div>
            </div>
            <div id="cp3" class="calib-point-wrapper" style="top:80%; left:20%;">
                <svg class="calib-ring" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45"></circle></svg>
                <div class="calib-point">3</div>
            </div>
            <div id="cp4" class="calib-point-wrapper" style="top:80%; left:80%;">
                <svg class="calib-ring" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45"></circle></svg>
                <div class="calib-point">4</div>
            </div>
            <div id="cp5" class="calib-point-wrapper" style="top:50%; left:50%;">
                <svg class="calib-ring" viewBox="0 0 100 100"><circle cx="50" cy="50" r="45"></circle></svg>
                <div class="calib-point">5</div>
            </div>
        </div>
    </div>

    <!-- éŠæˆ²ç•«é¢ -->
    <div id="game-container" style="display: none; width:100%; height:100%;">
        <div id="target" class="target-wrapper">
            <svg class="progress-ring" viewBox="0 0 100 100">
                <circle id="progress-bar" cx="50" cy="50" r="45"></circle>
            </svg>
            <div id="target-icon" class="target-icon">ğŸ¦</div>
        </div>
    </div>

    <script>
        const gameConfig = {
            smoothing: 0.8, 
            pointsToCalibrate: 5,
            calibratedCount: 0,
            items: [
                { char: 'ğŸ¦', name: 'å°é³¥' },
                { char: 'ğŸ¸', name: 'é’è›™' },
                { char: 'ğŸ¥', name: 'å°é›' },
                { char: 'ğŸ±', name: 'å°è²“' }
            ],
            currentIndex: 0,
            calibDuration: 1500 // çœ¼ç›æ³¨è¦–æ ¡æ­£é»éœ€è¦çš„æ™‚é–“ (æ¯«ç§’)
        };

        let screenX = window.innerWidth / 2;
        let screenY = window.innerHeight / 2;
        let objX = 0, objY = 0;
        let velX = 3, velY = 3;
        let isGazing = false;
        let gazeStartTime = 0;
        let isGameRunning = false;
        let isCalibrating = false;
        let currentCalibPointIdx = 1;

        window.onload = function() {
            webgazer.params.imgWidth = 160;
            webgazer.params.imgHeight = 120;
            
            webgazer.setGazeListener((data, clock) => {
                if (!data) return;
                screenX = screenX * gameConfig.smoothing + data.x * (1 - gameConfig.smoothing);
                screenY = screenY * gameConfig.smoothing + data.y * (1 - gameConfig.smoothing);

                const dot = document.getElementById('gaze-dot');
                dot.style.left = screenX + 'px';
                dot.style.top = screenY + 'px';
            }).begin();

            webgazer.showVideoPreview(true).showPredictionPoints(false);

            const checkInit = setInterval(() => {
                if (webgazer.isReady()) {
                    clearInterval(checkInit);
                    document.getElementById('btn-init').disabled = false;
                    document.getElementById('btn-init').innerText = "é€²å…¥æ³¨è¦–æ ¡æ­£";
                    document.getElementById('status-text').innerText = "ç³»çµ±å·²å°±ç·’";
                    
                    const video = document.getElementById('webgazerVideoFeed');
                    if (video) {
                        video.style.width = '100%'; video.style.height = '100%';
                        video.style.objectFit = 'cover';
                        document.getElementById('calibration-guide').appendChild(video);
                    }
                }
            }, 500);
        };

        function startCalibrationFlow() {
            document.getElementById('setup-screen').style.display = 'none';
            document.getElementById('calibration-screen').style.display = 'flex';
            document.getElementById('gaze-dot').style.display = 'block';
            isCalibrating = true;
            showOnlyCurrentPoint();
            speak("è«‹ç›¯è‘—é»ƒè‰²åœ“åœˆï¼Œç›´åˆ°å®ƒæ¶ˆå¤±");
            requestAnimationFrame(calibrationLoop);
        }

        function showOnlyCurrentPoint() {
            for(let i=1; i<=5; i++) {
                document.getElementById('cp' + i).style.display = (i === currentCalibPointIdx) ? 'flex' : 'none';
            }
        }

        // æ ¡æ­£å¾ªç’°ï¼šåˆ¤æ–·çœ¼ç›æ˜¯å¦ç›¯è‘—ç•¶å‰æ ¡æ­£é»
        function calibrationLoop(time) {
            if (!isCalibrating) return;

            const el = document.getElementById('cp' + currentCalibPointIdx);
            if (el) {
                const rect = el.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dist = Math.hypot(screenX - centerX, screenY - centerY);
                const ring = el.querySelector('circle');

                if (dist < 120) { // çœ¼ç›æ³¨è¦–ä¸­
                    if (!gazeStartTime) gazeStartTime = time;
                    const progress = Math.min((time - gazeStartTime) / gameConfig.calibDuration, 1);
                    ring.style.strokeDashoffset = 283 - (progress * 283);

                    if (progress >= 1) {
                        // è¨˜éŒ„æ ¡æ­£æ•¸æ“š
                        if (typeof webgazer.recordScreenClickData === 'function') {
                            webgazer.recordScreenClickData(centerX, centerY);
                        }
                        playSimpleBeep(600, 0.1);
                        
                        gazeStartTime = 0;
                        currentCalibPointIdx++;
                        
                        if (currentCalibPointIdx > 5) {
                            isCalibrating = false;
                            finishCalibration();
                        } else {
                            showOnlyCurrentPoint();
                        }
                    }
                } else {
                    gazeStartTime = 0;
                    ring.style.strokeDashoffset = 283;
                }
            }
            requestAnimationFrame(calibrationLoop);
        }

        function finishCalibration() {
            speak("æ ¡æ­£å®Œæˆï¼ŒéŠæˆ²é–‹å§‹");
            document.getElementById('calibration-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            isGameRunning = true;
            initTarget();
            requestAnimationFrame(gameLoop);
        }

        function initTarget() {
            const item = gameConfig.items[gameConfig.currentIndex];
            const icon = document.getElementById('target-icon');
            icon.innerText = item.char;
            
            objX = Math.random() * (window.innerWidth - 300) + 150;
            objY = Math.random() * (window.innerHeight - 300) + 150;
            
            velX = (Math.random() > 0.5 ? 1 : -1) * 3;
            velY = (Math.random() > 0.5 ? 1 : -1) * 3;

            resetProgress();
            speak("è«‹æ‰¾å‡º" + item.name);
        }

        function gameLoop(time) {
            if (isGameRunning) {
                objX += velX;
                objY += velY;

                if (objX < 100 || objX > window.innerWidth - 100) velX *= -1;
                if (objY < 100 || objY > window.innerHeight - 100) velY *= -1;

                const target = document.getElementById('target');
                target.style.left = objX + 'px';
                target.style.top = objY + 'px';

                const dist = Math.hypot(screenX - objX, screenY - objY);
                const threshold = 180; 

                if (dist < threshold) {
                    if (!isGazing) { 
                        gazeStartTime = time; 
                        isGazing = true;
                        playSimpleBeep(400, 0.05);
                    }
                    
                    const duration = 1200; 
                    const progress = Math.min((time - gazeStartTime) / duration, 1);
                    document.getElementById('progress-bar').style.strokeDashoffset = 283 - (progress * 283);
                    
                    if (progress >= 1) {
                        isGameRunning = false;
                        handleSuccess();
                    }
                } else {
                    isGazing = false;
                    resetProgress();
                    gazeStartTime = 0;
                }
            }
            requestAnimationFrame(gameLoop);
        }

        function resetProgress() {
            document.getElementById('progress-bar').style.strokeDashoffset = 283;
        }

        function handleSuccess() {
            const currentItem = gameConfig.items[gameConfig.currentIndex];
            speak(currentItem.name + "ï¼Œå¥½å»å•Šï¼æ•æ‰æˆåŠŸï¼");
            triggerRewardEffect();

            setTimeout(() => {
                gameConfig.currentIndex = (gameConfig.currentIndex + 1) % gameConfig.items.length;
                isGameRunning = true;
                initTarget();
            }, 2500);
        }

        function speak(text) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'zh-HK';
            utterance.rate = 0.9;
            window.speechSynthesis.speak(utterance);
        }

        function playSimpleBeep(freq, dur) {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + dur);
                osc.start();
                osc.stop(ctx.currentTime + dur);
            } catch(e) {}
        }

        function triggerRewardEffect() {
            confetti({
                particleCount: 150,
                spread: 70,
                origin: { y: 0.6 },
                colors: ['#FFD700', '#00FF7F', '#FF4500', '#1E90FF']
            });
            playSimpleBeep(800, 0.5);
        }
    </script>
</body>
</html>